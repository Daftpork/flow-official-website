{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.25,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.4,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform float uTime;\nuniform vec2 uMousePos;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0, 0);\ncase 1: return vec3(0.807843137254902, 0.807843137254902, 0.807843137254902);\ncase 2: return vec3(0, 0, 0);\ncase 3: return vec3(0.6666666666666666, 0.6666666666666666, 0.6666666666666666);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}float getStop(int index) {\nswitch(index) {\ncase 0: return 0.0000;\ncase 1: return 0.4625;\ncase 2: return 0.5531;\ncase 3: return 0.8187;\ncase 4: return 0.8969;\ncase 5: return 0.0000;\ncase 6: return 0.0000;\ncase 7: return 0.0000;\ncase 8: return 0.0000;\ncase 9: return 0.0000;\ncase 10: return 0.0000;\ncase 11: return 0.0000;\ncase 12: return 0.0000;\ncase 13: return 0.0000;\ncase 14: return 0.0000;\ncase 15: return 0.0000;\ndefault: return 0.0;\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}vec3 linear_from_srgb(vec3 rgb) {\nreturn pow(max(rgb, vec3(0.0)), vec3(2.2));\n}vec3 srgb_from_linear(vec3 lin) {\nreturn pow(max(lin, vec3(0.0)), vec3(1.0/2.2));\n}vec3 safeCbrt(vec3 v) {\nreturn sign(v) * pow(abs(v), vec3(1.0/3.0));\n}vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) {\nconst mat3 kCONEtoLMS = mat3(\n0.4121656120, 0.2118591070, 0.0883097947,\n0.5362752080, 0.6807189584, 0.2818474174,\n0.0514575653, 0.1074065790, 0.6302613616);\nconst mat3 kLMStoCONE = mat3(\n4.0767245293, -1.2681437731, -0.0041119885,\n-3.3072168827, 2.6093323231, -0.7034763098,\n0.2307590544, -0.3411344290, 1.7068625689);\nvec3 lms1 = safeCbrt( kCONEtoLMS*lin1 );\nvec3 lms2 = safeCbrt( kCONEtoLMS*lin2 );\nvec3 lms = mix( lms1, lms2, a );\nlms *= 1.0 + 0.025 * a * (1.0-a);\nreturn kLMStoCONE * (lms * lms * lms);\n}vec3 getGradientColor(float position) {\nposition = clamp(position, 0.0, 1.0);\nif (5 <= 1) return getColor(0);for (int i = 0; i < 15; i++) {\nif (i >= 5 - 1) break;\nfloat stopA = getStop(i);\nfloat stopB = getStop(i + 1);\nif (position <= stopB || i == 5 - 2) {\nfloat denom = max(stopB - stopA, 0.00001);\nfloat t = clamp((position - stopA) / denom, 0.0, 1.0);\nvec3 linA = linear_from_srgb(getColor(i));\nvec3 linB = linear_from_srgb(getColor(i + 1));\nvec3 mixed = oklab_mix(linA, linB, t);\nreturn srgb_from_linear(mixed);\n}\n}\nreturn getColor(min(5 - 1, 15));\n}out vec4 fragColor;vec3 applyColorToPosition(float position) {\nvec3 color = vec3(0);\nposition -= (uTime * 0.01 + 0.4000);\nfloat cycle = floor(position);\nbool reverse = 0.0000 > 0.5 && int(cycle) % 2 == 0;\nfloat animatedPos = reverse ? 1.0 - fract(position) : fract(position);color = getGradientColor(animatedPos);\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor += dither;\nreturn color;\n}vec3 radialGrad(vec2 uv) {\nfloat position = length(uv);\nreturn applyColorToPosition(position);\n}vec3 getGradient(vec2 uv) {\nreturn radialGrad(uv);\n}vec3 getColor(vec2 uv) {return getGradient(uv);return vec3(0, 0, 0);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= max(0.2000*2., 1e-5);\nuv = rotate(uv, (0.3915 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":true},"id":"gradient"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.5,"layerType":"effect","type":"caustics","usesPingPong":false,"speed":0.5,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;vec4 permute(vec4 t) {\nreturn t * (t * 34.0 + 133.0);\n}vec3 grad(float hash) {\nvec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\nvec3 cuboct = cube;float index0 = step(0.0, 1.0 - floor(hash / 16.0));\nfloat index1 = step(0.0, floor(hash / 16.0) - 1.0);cuboct.x *= 1.0 - index0;\ncuboct.y *= 1.0 - index1;\ncuboct.z *= 1.0 - (1.0 - index0 - index1);float type = mod(floor(hash / 8.0), 2.0);\nvec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));vec3 grad = cuboct * 1.22474487139 + rhomb;grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;return grad;\n}\nvec4 bccNoiseDerivativesPart(vec3 X) {\nvec3 b = floor(X);\nvec4 i4 = vec4(X - b, 2.5);\nvec3 v1 = b + floor(dot(i4, vec4(.25)));\nvec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\nvec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\nvec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\nvec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\nhashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\nhashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\nvec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\nvec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\nvec4 aa = a * a; vec4 aaaa = aa * aa;\nvec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\nvec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\nvec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\nvec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n+ mat4x3(g1, g2, g3, g4) * aaaa;\nreturn vec4(derivative, dot(aaaa, extrapolations));\n}\nvec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) {\nmat3 orthonormalMap = mat3(\n0.788675134594813, -0.211324865405187, -0.577350269189626,\n-0.211324865405187, 0.788675134594813, -0.577350269189626,\n0.577350269189626, 0.577350269189626, 0.577350269189626);\nX = orthonormalMap * X;\nvec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);\nreturn vec4(result.xyz * orthonormalMap, result.w);\n}float ease (int easingFunc, float t) {\nreturn t;\n}vec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src - dst;\n}const float PI = 3.14159265359;vec4 normalizeNoise(vec4 noise, float amount) {\nreturn mix(noise, (noise + 0.5) * 0.5, amount);\n}mat2 rotate2d(float angle) {\nreturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}vec4 getNoise(vec3 p) {\nvec4 noise = bccNoiseDerivatives_XYBeforeZ(p);\nreturn normalizeNoise(noise, 0.4000);\n}void getCaustics(vec2 uv, out vec4 outNoise, out vec3 outColor) {\nvec2 aspect = vec2(uResolution.x/uResolution.y, 1);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 drift = vec2(0, 0.0000 * uTime * 0.0125);\nvec2 pos = vec2(0.5, 0.5) + drift * rotate2d(0.0000 * -2. * PI);\nfloat mDist = ease(0, max(0.,1. - distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if(0 == 1) {\nmDist = max(0., (0.5 - mDist));\n}uv -= pos;\nuv = uv * aspect * rotate2d(0.0000 * 2. * PI) * vec2(1. - 0.0000, 1.) * 16.0 * 0.3000;float refraction = mix(0.25, 1.3, 0.6600);vec3 p = vec3(uv, uTime * 0.05);\nvec4 noise = getNoise(p);\nvec4 baseNoise = noise;\nvec4 balanceNoise = getNoise(p - vec3(baseNoise.xyz / 32.0) * refraction);\nnoise = getNoise(p - vec3(balanceNoise.xyz / 16.0) * refraction);float balancer = (0.5 + 0.5 * balanceNoise.w);\nfloat normalized = pow(0.5 + 0.5 * noise.w, 2.);\nfloat value = mix(0., normalized + 0.2 * (1.0 - normalized), balancer * mDist);\noutNoise = baseNoise * mDist;\noutColor = vec3(1, 1, 1) * value;\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 causticNoise;\nvec3 causticColor;\ngetCaustics(uv, causticNoise, causticColor);\nvec4 color = texture(uTexture, uv + causticNoise.xy * 0.01 * 1.0000);\nif(2 > 0) {\nvec3 blended = blend(2, color.rgb, causticColor);\ncolor.rgb = mix(color.rgb, blended, 1.0000);\n} else {\ncolor.rgb = causticColor * 1.0000;\n}\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"caustics"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.5,"layerType":"effect","type":"mouseDraw","usesPingPong":true,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0.29,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uTexture;\nuniform sampler2D uPingPongTexture;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn 1. - (1. - src) * (1. - dst);\n}uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float PI = 3.1415926;out vec4 fragColor;vec3 rgb2hsv(vec3 c) {\nvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\nvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\nvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y);\nfloat e = 1.0e-10;\nreturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}vec2 angleToDir(float angle) {\nfloat rad = angle * 2.0 * PI;\nreturn vec2(cos(rad), sin(rad));\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pingpongUv = uv;vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb;\nvec3 mouseTrail = rgb2hsv(mouseRgb);\nfloat angle = mouseTrail.x;\nfloat strength = mouseTrail.z * (0.4800 * 5.0);vec2 direction = angleToDir(angle);vec4 bg = texture(uTexture, uv - (direction * 0.1 * strength * 0.3900));\nvec4 color = vec4(0,0,0,1);color.rgb = vec3(strength * mix(mouseRgb, vec3(1, 1, 1), 1.0000));\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;if(4 > 0) {\nvec3 blendedRgb = blend(4, color.rgb + dither, bg.rgb);\nfragColor = vec4(mix(bg.rgb, blendedRgb, mouseTrail.z), 1.0);\n} else {\nfragColor = mix(bg, color, mouseTrail.z);\n}\n}","#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uPingPongTexture;\nuniform vec2 uPreviousMousePos;\nuniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;const float PI = 3.1415926;\nconst float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) {\nvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\nreturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}vec3 rgb2hsv(vec3 c) {\nvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\nvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\nvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y);\nfloat e = 1.0e-10;\nreturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}mat2 rot(float a) {\nreturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}vec2 angleToDir(float angle) {\nfloat rad = angle * 2.0 * PI;\nreturn vec2(cos(rad), sin(rad));\n}vec2 liquify(vec2 st, vec2 dir) {\nfloat aspectRatio = uResolution.x / uResolution.y;\nst.x *= aspectRatio;\nfloat amplitude = 0.0025;\nfloat freq = 6.;\nfor (float i = 1.0; i <= 5.0; i++) {\nst = st * rot(i / 5.0 * PI * 2.0);\nst += vec2(\namplitude * cos(i * freq * st.y + uTime * 0.02 * dir.x),\namplitude * sin(i * freq * st.x + uTime * 0.02 * dir.y)\n);\n}\nst.x /= aspectRatio;\nreturn st;\n}vec3 calculateTrailContribution(vec2 mousePos, vec2 prevMousePos, vec2 uv, vec2 correctedUv, float aspectRatio, float radius) {\nvec2 dir = (mousePos - prevMousePos) * vec2(aspectRatio, 1.0);\nfloat angle = atan(dir.y, dir.x);\nif (angle < 0.0) angle += TWOPI;\nvec2 mouseVec = mousePos - prevMousePos;\nfloat mouseLen = length(mouseVec);\nvec2 mouseDir = mouseLen > 0.0 ? mouseVec / mouseLen : vec2(0.0);\nvec2 posToUv = (correctedUv - prevMousePos) * vec2(aspectRatio, 1.0);\nfloat projection = clamp(dot(posToUv, mouseDir * vec2(aspectRatio, 1.0)), 0.0, mouseLen * aspectRatio);\nvec2 closestPoint = prevMousePos * vec2(aspectRatio, 1.0) + mouseDir * vec2(aspectRatio, 1.0) * projection;\nfloat distanceToLine = distance(correctedUv, closestPoint);\nfloat s = (1.0 + radius)/(distanceToLine + radius) * radius;\nvec3 color = vec3(angle / TWOPI, 1.0, 1.0);\nvec3 pointColor = hsv2rgb(color);\npointColor = pow(pointColor, vec3(2.2));\nfloat intensity = pow(s, 10.0 * (1. - 0.6900 + 0.1));\nreturn pointColor * intensity;\n}void main() {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec2 uv = vTextureCoord;\nvec2 correctedUv = (uv) * vec2(aspectRatio, 1.0);vec3 lastFrameColor = texture(uPingPongTexture, uv).rgb;\nvec3 lastFrameColorGamma = pow(lastFrameColor, vec3(2.2));\nvec3 hsv = rgb2hsv(lastFrameColor);\nvec3 hsvGamma = rgb2hsv(lastFrameColorGamma);\nvec2 prevDir = angleToDir(hsv.x);\nfloat prevStrength = hsvGamma.z;\nvec2 dir = (uMousePos - uPreviousMousePos) * vec2(aspectRatio, 1.0);\nfloat dist = length(dir);\nfloat blurAmount = 0.03 * prevStrength;\nuv = uv - prevDir * blurAmount;\nuv = mix(uv, liquify(uv - prevDir * 0.005, prevDir), (1. - prevStrength) * 0.7700);\nlastFrameColor = texture(uPingPongTexture, uv).rgb;\nlastFrameColor = pow(lastFrameColor, vec3(2.2));\nint numPoints = int(max(12.0, dist * 24.0));\nfloat speedFactor = clamp(dist, 0.7, 1.3);\nfloat radius = mix(0.1, 0.7, 0.4500 * speedFactor);\nvec3 trailColor = vec3(0.0);\nint iter = min(numPoints, 24);\nfor (int i = 0; i <= iter; i++) {\nfloat t = float(i) / float(numPoints);\nvec2 interpPos = mix(uPreviousMousePos, uMousePos, t);\nvec2 prevInterpPos = i > 0 ? mix(uPreviousMousePos, uMousePos, float(i-1) / float(numPoints)) : uPreviousMousePos;\ntrailColor += calculateTrailContribution(interpPos, prevInterpPos, uv, correctedUv, aspectRatio, radius);\n}\ntrailColor = trailColor / float(min(numPoints, 50) + 1);\nvec3 blurredLastFrame = vec3(0.0);\nfloat clampedDist = clamp(length(trailColor) * dist, 0.0, 1.0);\nfloat blurRadius = 0.005;\nblurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(blurRadius, 0.0)).rgb, vec3(2.2)) * 0.2;\nblurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(-blurRadius, 0.0)).rgb, vec3(2.2)) * 0.2;\nblurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(0.0, blurRadius)).rgb, vec3(2.2)) * 0.2;\nblurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(0.0, -blurRadius)).rgb, vec3(2.2)) * 0.2;\nblurredLastFrame += lastFrameColor * 0.2;\nblurredLastFrame *= pow(0.9200, 0.2);\nvec3 draw = mix(blurredLastFrame, trailColor, clampedDist);\ndraw = pow(draw, vec3(1.0/2.2));\ndraw.r = max(0.0, draw.r - 0.01);\ndraw.g = max(0.0, draw.g - 0.01);\ndraw.b = max(0.0, draw.b - 0.01);\nfragColor = vec4(draw, 1.0);\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"mouse_draw"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.5,"layerType":"effect","type":"circle","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src * dst;\n}out vec4 fragColor;mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);\nfloat lum = luma(bg.rgb);\nfloat displacement = (lum - 0.5) * 0.0000 * 0.5;\nvec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0);\nvec2 skew = vec2(max(0.4600, 0.001), max(1.0 - 0.4600, 0.001));\nfloat halfRadius = 0.5500 * 0.5;\nfloat falloffAmount = max(1.0000, 0.001);\nfloat innerEdge = halfRadius - falloffAmount * halfRadius * 0.5;\nfloat outerEdge = halfRadius + falloffAmount * halfRadius * 0.5;\nvec2 pos = vec2(0.5, 0.5);\nconst float TWO_PI = 6.28318530718;\nvec2 scaledUV = uv * aspectRatio * rot(0.0000 * TWO_PI) * skew;\nvec2 scaledPos = pos * aspectRatio * rot(0.0000 * TWO_PI) * skew;\nfloat radius = distance(scaledUV, scaledPos);\nfloat falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius);\nfalloff = (1.0 - falloff) * 1.0000;\nvec3 circle = vec3(0, 0, 0) * falloff;vec3 blended = blend(3, vec3(0, 0, 0), bg.rgb);\ncircle = mix(bg.rgb, blended, falloff);\nvec4 color = vec4(circle, max(bg.a, falloff));\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"circle"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.5,"layerType":"effect","type":"gradientMap","usesPingPong":false,"speed":0.5,"texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0.00392156862745098, 0.00392156862745098, 0.00784313725490196);\ncase 1: return vec3(0.3411764705882353, 0.3411764705882353, 0.3411764705882353);\ncase 2: return vec3(0.7333333333333333, 0.7333333333333333, 0.7333333333333333);\ncase 3: return vec3(1, 1, 1);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}float getStop(int index) {\nswitch(index) {\ncase 0: return 0.0000;\ncase 1: return 0.6438;\ncase 2: return 0.8187;\ncase 3: return 0.9594;\ncase 4: return 0.0000;\ncase 5: return 0.0000;\ncase 6: return 0.0000;\ncase 7: return 0.0000;\ncase 8: return 0.0000;\ncase 9: return 0.0000;\ncase 10: return 0.0000;\ncase 11: return 0.0000;\ncase 12: return 0.0000;\ncase 13: return 0.0000;\ncase 14: return 0.0000;\ncase 15: return 0.0000;\ndefault: return 0.0;\n}\n}float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}float rand(vec2 co) {\nreturn fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}vec3 linear_from_srgb(vec3 rgb)\n{\nreturn pow(max(rgb, vec3(0.0)), vec3(2.2));\n}vec3 srgb_from_linear(vec3 lin)\n{\nreturn pow(max(lin, vec3(0.0)), vec3(1.0/2.2));\n}vec3 safeCbrt(vec3 v) {\nreturn sign(v) * pow(abs(v), vec3(1.0/3.0));\n}vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) {\nconst mat3 kCONEtoLMS = mat3(\n0.4121656120, 0.2118591070, 0.0883097947,\n0.5362752080, 0.6807189584, 0.2818474174,\n0.0514575653, 0.1074065790, 0.6302613616);\nconst mat3 kLMStoCONE = mat3(\n4.0767245293, -1.2681437731, -0.0041119885,\n-3.3072168827, 2.6093323231, -0.7034763098,\n0.2307590544, -0.3411344290, 1.7068625689);\nvec3 lms1 = safeCbrt(kCONEtoLMS*lin1);\nvec3 lms2 = safeCbrt(kCONEtoLMS*lin2);\nvec3 lms = mix(lms1, lms2, a);\nlms *= 1.0 + 0.02 * a * (1.0 - a);\nreturn kLMStoCONE*(lms*lms*lms);\n}vec3 getGradientColor(float position) {\nposition = clamp(position, 0.0, 1.0);\nfor (int i = 0; i < 4 - 1; i++) {\nfloat colorPosition = getStop(i);\nfloat nextColorPosition = getStop(i + 1);\nif (position <= nextColorPosition) {\nfloat stopDelta = nextColorPosition - colorPosition;\nfloat mixFactor = clamp(stopDelta > 0.0001 ? (position - colorPosition) / stopDelta : 0.0, 0.0, 1.0);\nvec3 linStart = linear_from_srgb(getColor(i));\nvec3 linEnd = linear_from_srgb(getColor(i + 1));\nvec3 mixedLin = oklab_mix(linStart, linEnd, mixFactor);\nreturn srgb_from_linear(mixedLin);\n}\n}\nreturn getColor(4 - 1);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);\nfloat position = smoothstep(0., 1., luma(color.rgb)) * (0.4500 * 2.);\nfloat posOffset = (dot(vec2(0.49249419279907086, 0.5007433217189315).x, vec2(0.49249419279907086, 0.5007433217189315).y) + 0.2300 + 0.0001) * 2.;\nposition -= (uTime*0.01 + posOffset);\nfloat cycle = floor(position);\nbool reverse = 0.0000 > 0.5 && int(cycle) % 2 == 0;\nfloat animatedPos = reverse ? fract(-position) : fract(position);\nanimatedPos = reverse ? fract(-position) : fract(position);\nanimatedPos = clamp(animatedPos, 0.0, 1.0);vec3 gradientColor = getGradientColor(animatedPos);\nfloat dither = rand(gl_FragCoord.xy) * 0.005;\ngradientColor += dither;\nvec3 mixedColor = mix(color.rgb, gradientColor, 1.0000);color.rgb = mixedColor;\nfragColor = color;\n;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"gradient_map"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"glyphDither","usesPingPong":false,"texture":{"src":"data:image/png;base64,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","sampler":"uCustomTexture"},"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uSprite;\nuniform sampler2D uCustomTexture;uniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn 1. - (1. - src) * (1. - dst);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat aspectRatio = uResolution.x / uResolution.y;\nfloat aspectCorrection = mix(aspectRatio, 1./aspectRatio, 0.5);float gridSize = mix(0.05, 0.005, 0.9000);float baseGrid = 1.0 / gridSize;\nvec2 cellSize = vec2(1.0/(baseGrid * aspectRatio), 1.0/baseGrid) * aspectCorrection;\nvec2 offsetUv = uv - pos;\nvec2 cell = floor(offsetUv / cellSize);\nvec2 cellCenter = (cell + 0.5) * cellSize;\nvec2 pixelatedCoord = cellCenter + pos;\nvec4 bg = texture(uTexture, vTextureCoord);\nvec4 color = texture(uTexture, pixelatedCoord);float luminance = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\nluminance = mix(luminance, 1.0 - luminance, float(0));\nfloat gamma = pow(mix(0.2, 2.2, 0.4000), 2.2);ivec2 customTextureSize = textureSize(uCustomTexture, 0);\nivec2 spriteTextureSize = textureSize(uSprite, 0);\nfloat selectedWidth = mix(float(spriteTextureSize.x), float(customTextureSize.x), float(6 == 6));\nfloat GLYPH_HEIGHT = mix(float(spriteTextureSize.y), float(customTextureSize.y), float(6 == 6));\nfloat scaleFactor = gridSize / GLYPH_HEIGHT;\nfloat numSprites = max(1.0, selectedWidth / GLYPH_HEIGHT);\nfloat numGlyphRows = 1.0;float spriteIndex = clamp(floor(luminance * numSprites), 0.0, numSprites - 1.0);\nfloat spriteIndexWithGamma = clamp(floor(luminance * numSprites * gamma), 0.0, numSprites - 1.0);\nfloat phaseOffset = floor(0.0000 * numSprites + 0.5);\nspriteIndexWithGamma = mod(spriteIndexWithGamma + phaseOffset, numSprites);\nfloat glyphIndex = 0.0;float normalizedSpriteSizeX = 1.0 / numSprites;\nfloat normalizedSpriteSizeY = 1.0 / numGlyphRows;float spriteX = (spriteIndexWithGamma * normalizedSpriteSizeX);vec2 spriteSheetUV = vec2(spriteX, glyphIndex / numGlyphRows);vec2 spriteSize = vec2(GLYPH_HEIGHT / aspectRatio, GLYPH_HEIGHT) * scaleFactor * aspectCorrection;\nvec2 localOffset = mod(uv - pos, spriteSize) / spriteSize;float inset = 0.5 / GLYPH_HEIGHT;\nlocalOffset = clamp(localOffset, inset, 1.0 - inset);spriteSheetUV += vec2(localOffset.x * normalizedSpriteSizeX, localOffset.y * normalizedSpriteSizeY);vec4 spriteColor = vec4(0.0);spriteColor = texture(uCustomTexture, spriteSheetUV);\nfloat alpha = smoothstep(0.0, 1.0, spriteColor.r);vec3 cc = (color.rgb - spriteIndex * 0.04) * 1.4;\nvec3 col = cc;vec3 dithered = mix(\nmix(vec3(0.0), vec3(1.0), float(0)),\ncol,\nalpha\n);\ncolor.rgb = mix(bg.rgb, dithered, 1.0000);\nvec3 blended = blend(4, dithered, bg.rgb);\ncolor.rgb = mix(bg.rgb, blended, 1.0000);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"texture":{"src":"","sampler":"uSprite"}},"id":"glyph_dither"}],"options":{"name":"UnicornStudio Hero (Remix)","fps":120,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":true},"version":"2.0.2","id":"tYXu0yDOP3LRElj0FDL6"}